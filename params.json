{"name":"Pydiction","tagline":"Python Tab-completion for Vim","body":"Description\r\n===========\r\nPydiction allows you to Tab-complete Python code in Vim such as keywords, built-ins, standard library, and third-party modules. \r\n\r\nIt doesn't require installing any dependencies. It simply consists of three main files:\r\n    \r\n    python_pydiction.vim  -- Vim plugin that autocompletes Python code.\r\n    complete-dict         -- Dictionary file of Python keyword & modules, etc.\r\n    pydiction.py          -- Python script to optionally add more modules to complete-dict.\r\n\r\nThe bundled dictionary comes with most things you will likely need in your day-to-day Python programming, and the included\r\nPython script allows you to easily append new modules to the dictionary. So you don't have to wait around for me to add them.\r\nAnd you can teach Pydiction to complete your project's own API very quickly. Some third-party libraries already supported are:\r\n`Django` `Flask` `Requests` `Twisted` `Numpy` `Psycopg2` `PyGreSQL` `SQLite3` `MySQLdb` `OpenGL` `Pygame` `wxPython` `PyGTK` \r\n`PyQT4` `OpenID` and more.\r\n\r\nSince Pydiction just uses a flat dictionary file, it's extremely flexible because you can do things like re-order how you want\r\nthings to appear in your popup completion menus. By default it will be in alphabetical order, but if you want `else` to come \r\nbefore `elif`, you can.\r\n\r\nPydiction is often misunderstood when compared to other forms of python code completion. Pydiction doesn't have to do \r\nany source code analysis. It only uses the dictionary of terms. This is its strength and weakness when used alone. It's a\r\nstrength because of how stable it allows the plugin to be. And Pydiction really shines when completing 3rd party libraries\r\nand frameworks and basic keywords, but not for things that dictionary completion isn't suited for. For that, you'll want \r\nomni-completion too. See the `Tips` section for how to get the best of all worlds. \r\n\r\nInstallation\r\n============\r\nIf you have Pathogen installed:\r\n\r\n    cd ~/.vim/bundle\r\n    git clone https://github.com/rkulla/pydiction.git\r\n\r\nor use a plugin manager like Vimogen (https://github.com/rkulla/vimogen) to install and manage Pydiction and all of your plugins.\r\n\r\nOtherwise:\r\n\r\n    - UNIX/LINUX/OSX: Put python_pydiction.vim in ~/.vim/after/ftplugin/ \r\n    (Create this directory if doesn't yet exist. Vim looks there automatically)\r\n\r\n    - WINDOWS: Put python_pydiction.vim in C:\\vim\\vimfiles\\ftplugin\\\r\n    (Assuming you installed Vim to C:\\vim\\)\r\n\r\n    You may install complete-dict and pydiction.py anywhere (see the Configuration section),\r\n    but only python_pydiction.vim in the ftplugin directory because for .vim files only.\r\n\r\nConfiguration\r\n=============\r\nIn your vimrc file, first add the following line to enable filetype plugins:\r\n  \r\n    filetype plugin on\r\n\r\nthen make sure you set g:pydiction_location to the full path of where you installed complete-dict. Ex:\r\n    \r\n    let g:pydiction_location = '/path/to/complete-dict'\r\n\r\nfor example, if you used Pathogen to install Pydiction, you would set this to:\r\n\r\n    let g:pydiction_location = '/home/user/.vim/bundle/pydiction/complete-dict'\r\n\r\nand the dictionary will be available to all of your virtualenv's as well.\r\n\r\nYou can change the height of the completion menu by setting g:pydiction_menu_height in your vimrc:\r\n    \r\n    let g:pydiction_menu_height = 3\r\n\r\nThe default menu height is 8, meaning 8 items at a time will be shown. Some people prefer more or less and you can make it as large as you want since it will automatically know where to position the menu to be visible.\r\n\r\nNote: If you were using a version of Pydiction less than 1.0, make sure you delete the old pydiction way of doing things from your vimrc. You should ***NOT*** have this in your vimrc anymore:\r\n\r\n        if has(\"autocmd\")\r\n           autocmd FileType python set complete+=k/path/to/pydiction iskeyword+=.,(\r\n        endif \" has(\"autocmd\") \r\n\r\nIf you want to configure other things, such as how to get Pydiction to work with other plugins like `SnipMate` or the color of the menu, see the `Tips` section of this documentation.\r\n\r\n\r\nUsage (Plugin)\r\n==============\r\nIn Vim's INSERT mode, type part of a Python keyword, module name, attribute or method, then hit TAB:\r\n\r\n    raw<Tab>\r\n\r\nwill bring up a menu of possibilities, such as:\r\n\r\n    raw_input(\r\n    raw_unicode_escape_decode(\r\n    raw_unicode_escape_encode(\r\n\r\nPressing `Tab` again scrolls down the menu so you can select something else. Then type a popup-menu key:\r\n\r\n    <Space>              -- Accept current match and insert a space.\r\n    CTRL-Y               -- Accept current match and and don't insert a space.\r\n    <Enter>              -- Accept current match and insert a newline.\r\n    <ESC> or CTRL-E      -- Close the menu and do not accept any match.\r\n\r\n    You can also now use Shift-Tab to Tab backwards through the popup menu.\r\n\r\nTyping:\r\n\r\n    os.p<Tab>\r\n\r\npops up:\r\n\r\n    os.pardir\r\n    os.path\r\n    os.pathconf(\r\n    os.pathconf_names\r\n    os.pathsep\r\n    os.pipe(\r\n    ...\r\n\r\nTyping:\r\n\r\n    co<Tab>\r\n\r\npops up:\r\n\r\n    continue\r\n    coerce(\r\n    compile(\r\n    ...\r\n\r\nTyping:\r\n\r\n    dj[Tab]\r\n\r\npops up:\r\n\r\n    django\r\n    django.db\r\n    django.utils\r\n    django.conf\r\n    django.template\r\n    ...\r\n\r\nTyping:\r\n\r\n    def __i<Tab>\r\n\r\npops up:\r\n\r\n    def __init__(\r\n    def __iter__(\r\n\r\nAs of Pydiction 1.2, there's support for completing modules that were imported via \"from module import submodule\". For example, you could do:\r\n\r\n    from xml.parsers import expat\r\n    expat.P<Tab>\r\n\r\nwhich expands to:\r\n\r\n    expat.ParserCreate(\r\n\r\nPython's newer \"import module as X\" syntax isn't supported by default, since it would be impossible for Pydiction to know what you'll alias a module to. However, you can either add the alias to complete-dict or just use pythoncomplete.vim's Omnicompletition by typing `<C-X><C-O>`. You can also use the omni-completion to complete other things that aren't in the complete-dict dictionary, such as variables:\r\n\r\n    i = 3\r\n    i.b<Ctrl-x><Ctrl-o>   # expands to: i.bit_length(\r\n\r\nSee my Tips section below for more.\r\n\r\n\r\nIf you feel you're getting different results in your completion menu, it's probably because you don't have Vim set to ignore case. You can remedy this with \":set noic\"\r\n        \r\nUsage (Dictionary generator)\r\n============================\r\nYou can skip this section if you don't plan to add more modules to complete-dict yourself. Consult complete-dict to see if it already has the modules you intend to use.\r\n\r\nThis is the Python script used to create the \"complete-dict\" Vim dictionary file. I have created and bundled a default complete-dict for your use. I created it using a Linux system, so there won't be many real win32 specific modules in it. You're free to run pydiction.py to add or upgrade as many modules as you need. The dictionary file will still work if you're using windows, but it won't complete win32 related modules unless you tell it to. \r\n\r\nUSAGE: At a command prompt, run:\r\n\r\n    $ python pydiction.py <module> [<module> ...] [-v]\r\n\r\n(You need to have at least python 2.x installed.)\r\n\r\nSay you wanted to add a module called \"mymodule\" to complete-dict. Do the following:\r\n\r\n    $ python pydiction.py mymodule\r\n\r\nYou can input more than one module name on the command-line by separating them with spaces:\r\n\r\n    $ python pydiction.py mymodule1 mymodule2 mymodule3\r\n\r\nThe -v option will just write the results to stdout (standard output) instead of the complete-dict file:\r\n\r\n    $ ./pydiction.py -v datetime math\r\n\r\nIf the backup file \"complete-dict.last\" doesn't exist in the current directory, pydiction.py will create it for you. You should always keep a backup of your last working dictionary in case anything goes wrong, as it can get tedious having to recreate the file from scratch.\r\n\r\nIf complete-dict.last already exists, the script will ask if you want to overwrite your old backup with the new backup.\r\n\r\nIf you try to add a module that already exists in complete-dict, Pydiction will tell you it already exists, so don't worry about adding duplicates. In fact you can't add duplicates because every time pydiction.py runs it looks for and removes any duplicates in the file.\r\n\r\nWhen pydiction.py adds new modules to complete-dict, it does so in two phases. First it adds the fully-qualified name of the module. For example:\r\n\r\n    module.attribute\r\n    module.method(\r\n\r\nthen it adds the non-fully qualified name:\r\n\r\n    attribute\r\n    method(\r\n\r\nthis allows you to complete your python code in the way that you imported it. E.g.:\r\n\r\n    import module\r\n\r\nor:\r\n\r\n    from module import method\r\n\r\nSay you want to complete \"pygame.display.set_mode\". If you imported Pygame using \"import pygame\", then you can Tab-complete using:\r\n\r\n    pygame.di<Tab>\r\n\r\nto expand to \"pygame.display.\". Then type:\r\n\r\n    se<Tab>\r\n\r\nto expand to \"pygame.display.set_mode(\"\r\n\r\nNow say you imported using \"from pygame import display\". To expand to \"display.set_mode(\" type:\r\n\r\n    display.se<Tab>\r\n\r\nAnd if you imported using \"from pygame.display import set_mode\" type:\r\n\r\n    se<Tab>\r\n\r\nKeep in mind that if you don't use fully-qualified module names then you might get a lot of possible menu options popping up, so you may want to use more than just two letters before you hit Tab, to try to narrow down the list.\r\n\r\nAs of Pydiction 1.1 there is also limited support for string type method completion. For example:\r\n\r\n    \"\".jo<Tab>\"\r\n\r\nwill expand to:\r\n\r\n    \"\".join(\r\n\r\nmake sure you type at least two letters of the method name if this doesn't seem to work.\r\n\r\nThis only works for quoted strings, ie:\r\n\r\n    'foo bar'.st<Tab>\r\n    \r\nto get:\r\n\r\n    'foo bar'.startswith(\r\n\r\nbut you can't do:\r\n\r\n    s = 'foo bar'\r\n\r\n    s.st<Tab>\r\n\r\nif you want that behavior you can still use Vim 7's omni-completion:\r\n\r\n    s.st<Ctrl-x><Ctrl-o>\r\n\r\nwhich will also give you a preview window describing the methods as well as the argument list the methods take, e,g:\r\n\r\n    startswith(prefix[, start[, end]])\r\n    strip([chars])\r\n\r\nTo Tab-complete your own personal modules, you can put your functions in a separate file to be reused, as you normally would. For example, say you put the following function in a file called \"myFoo.py\":\r\n\r\n    def myBar():\r\n        print \"hi\"\r\n\r\nyou would then need to add myFoo to complete-dict by doing:\r\n\r\n    $ ./pydiction.py myFoo\r\n\r\nnow you can complete myFoo.myBar() by doing:  \r\n\r\n    myFoo.my<Tab>\r\n\r\nNote: You don't have to restart Vim after you update complete-dict nor do you have to use the pydiction.py script to add stuff to it; it's just a text file that you can also manually edit.\r\n\r\n\r\nAbout python_pydiction.vim\r\n==========================\r\nSee the `Usage (vim)` section if you just want to know how to use Pydiction inside of Vim. This section will go into detail what this plugin does behind the scenes.\r\n\r\nPydiction version 1.0 and greater uses a file called python_pydiction.vim, which is an ftplugin that only activates when you're editing a python file (e.g., you're editing a file with a .py extension or you've manually typed `:set filetype=python`). \r\n\r\nPast versions of pydiction didn't use a plugin but only required you to change the value of \"isk\" in your vimrc, which was not desirable. Version 1.0 and greater do not require you to manually change the value of isk. It now safely changes isk for you temporarily by only setting it while you're doing Tab-completion of Python code. It automatically changes isk back to its original value whenever Tab-completion isn't being activated. Again, only Tab-completion causes Pydiction to activate; not even other forms of ins-completion, such as `<Ctrl-x>` or `<Ctrl-n>` completion will activate Pydiction. So you're still free to use those other types of completion whenever you want to.\r\n\r\nPydiction works by using Vim's ins-completion functionality by temporarily remapping the Tab key to do the same thing as `I_CTRL-X_CTRL_K` (dictionary only completion). So when you are editing a Python file and you start typing the name of a Python keyword or module, you can press the Tab key to complete it. For example, if you type os.pa then press Tab, a pop up completion menu opens with:\r\n\r\n    os.pardir\r\n    os.path\r\n    os.pathconf(\r\n    os.pathconf_names\r\n    os.path.\r\n    os.path.__all__\r\n    os.path.__builtins__\r\n    os.path.__doc__\r\n    ...\r\n\r\nPressing Tab again while the menu is open will scroll down the menu. Then you should use a popup-menu key:\r\n\r\n    <Space>               Accept current match and insert a space.\r\n    CTRL-Y                Accept current match and and don't insert a space.\r\n    <Enter>               Accept current match and insert a newline.\r\n    <ESC> or CTRL-E       Close the menu and do not accept any match.\r\n\r\n    See `:help popupmenu-keys` for more options.\r\n\r\nAs of Pydiction 1.3 you can press Shift-Tab to complete searches in backwards order.\r\n\r\nPydiction temporarily sets completeopt to \"menu,menuone\", so that you can complete items that have one or more matches. It will set completeopt back to what it was originally after Tab-completion has finished.\r\n\r\nBy default, Pydiction ignores case while doing Tab-completion. If you want it to do case-sensitive searches, then `set noignorecase` (:set noic).\r\n\r\n\r\nAbout complete-dict\r\n===================\r\nThis is the dictionary file that python_pydiction.vim reads from and pydiction.py writes to. Without this file, Pydiction wouldn't know which Python keywords, built-ins and modules it can Tab-complete.\r\n\r\nYou can create your own complete-dict if you don't want to use the default one. The default complete-dict gives you a major head start as far as what you will be able to Tab-complete.\r\n\r\nThe default complete-dict currently contains python keywords: `and` `as` `assert` `break` `class` `continue` `def` `del` `elif` `else` `except` `exec` `finally` `for` `from` `global` `if` `import` `in` `is` `lambda` `nonlocal` `not` `or` `pass` `print` `raise` `return` `try` `while` `with` `yield`\r\n\r\nIt also contains most of the standard library and built-ins:  `__builtin__` `__future__` `os` `sys` `time` `re` `string` `str` `Tkinter` `urllib` etc.\r\n\r\nIt even contains complete-dict even comes with many third-party libraries such as: `Django` `Twisted` `Flask` `Requests` `Numpy` `Psycopg2` `PyGreSQL` `SQLite3` `MySQLdb` `ZSI` `LDAP` `OpenGL` `Pygame` `wxPython` `PyGTK` `PyQT4` `PyOgg` `Bcrypt` `OpenID` `GnuPGInterface` `OpenSSL` `Pygments` and more.\r\n\r\nAnd it contains useful dunder methods, conventions, etc such as: `self` `object` `__init__(` `__name__` `__main__` etc. This type of thing was manually added near the top of the bundled file. Anything you want to always appear first should go near the top of the file since it reads top-down.\r\n\r\nBecause it's just a text file, it's very flexible since you can do things like re-order how you want things to appear in your popup completion menus. By default \r\nthings will appear in alphabetical order, but if you want `else` to come before `elif`, there's nothing stopping you. In fact, the bundled dictionary comes with some keywords and stuff re-arranged by likely usage as best as I could manage.\r\n\r\nMake sure you download the latest version of Pydiction to get the most up-to-date version of complete-dict. New modules are usually added to it every release.\r\n\r\nIf you open complete-dict in your text editor you'll see sections in it for each module, such as:\r\n\r\n    --- import os ---\r\n    os.path\r\n    os.chdir(\r\n    os.chmod(\r\n    ...\r\n\r\n    --- from os import * ---\r\n    EX_CANTCREAT\r\n    EX_CONFIG\r\n    EX_DATAERR\r\n    ...\r\n\r\nIf certain attributes seem to be missing, it's probably because Pydiction removed them because they were duplicates. So first try searching the entire file for whatever string you assume is missing before you try adding it. \r\n\r\nIf you try to recreate complete-dict from scratch, you'll need to manually add the Python keywords and non-module stuff back into it. See the top few sections of the bundled complete-dict file for what I mean. Instead of deleting the file, I would use those manually added sections as a starting point, and then just append your own stuff from there.\r\n\r\nIf you don't want certain things to Tab-complete, such as Python keywords or certain modules, you can just delete them by hand from complete-dict.\r\n\r\nPydiction doesn't ignore \"private\" attributes or methods. I.e., those starting (but not ending) with one or two underscores, e.g., \"_foo\" or \"__foo\".  I have deleted most things starting with single underscore or double underscores from the included complete-dict just to keep it a little more sane since there were so many.  Python doesn't force things to be private, and you're free to add them if and when you want them. If you find any that you want to delete, open complete-dict in vim and run\r\n\r\n    :g/\\._[a-zA-Z]/d\r\n    :g/^_[a-zA-Z]/d\r\n    :g/^\\%(_\\=[^_]\\)*\\zs__\\%(.\\{-}__\\)\\@!/d\r\n    etc...\r\n\r\nPydiction vs other forms of completion\r\n======================================\r\n- Pydiction doesn't require any dependencies to be installs and you don't even need Python support to be compiled into your version of Vim. The dictionary based completion is very stable because it's native to Vim and the Pydiction plugin is only about 50 lines of code and unlikely to have errors -- not counting potential conflicts with other plugins, but those are usually easily fixable.\r\n\r\n- Because Pydiction uses a dictionary file, you don't have to import a module before you can complete it, nor do you even have to have the module installed on your machine. This makes completion very fast since it doesn't need to do any type deducing.\r\n\r\n- And because the dictionary file is just a static text file, you re-arrange how you want things to appear in the popup menus. By default things are sorted alphabetically, but if ou want `else` to come before `elif`, you can customize.\r\n\r\n- There is only one global instance of the dictionary file, which means pydiction won't try to dynamically create dictionaries in your project's folder. So there's no project folders you have to add to .gitignores or anything. And there's nothing special that you have to do to get Pydiction to work with `virtualenv` or other operating systems.\r\n\r\n- It can complete Python Keywords, built-ins, and Python module names and their attributes and methods. It can complete both the fully-qualified and non-fully qualified names. For example: `string.upper(`, `upper(`, `''.upper(`, and so forth.\r\n\r\n- Pydiction only uses the \"Tab\" key to complete, uses a special dictionary file to complete from, and only attempts to complete while editing Python files. This has the advantage of only requiring one keystroke to do completion and of not polluting all of the completion menus that you might be using for other types of completion, such as Vim's regular omni-completion or other completion scripts that you may be running.\r\n\r\n- Because Pydiction uses a dictionary file of possible completion items, it can complete 3rd party modules more accurately than other methods. You have full control over what it can and cannot complete. If it's unable to complete anything you can use pydiction.py to add a new module's contents to the dictionary, or you can manually add them using a text editor. In other words, you can teach Pydiction to learn what new things it can complete, just like you can with any snippet-based system -- except the snippets are for autocompleting the rest of a word and not for pasting entire templates like SnipMate does.\r\n\r\n- The dictionary is just a text file, which makes it portable across all platforms. For example, if you're a Pyramid user you can add all the Pyramid related modules to the dictionary file.py. The latest default complete-dict already contains all of the standard library, Python keywords, and many 3rd party modules like Django, Twisted, Numpy, Flask, Requests, Pygame, wxPython, PyQT4, PyGTK, ZSI, LDAP, MySQLdb, Psycopg2, PyGreSQL, OpenId, OpenSSL, Pygments and much more. To see the full-list of python modules Pydiction knows about, open complete-dict in Vim and run `:g/root modules`.\r\n\r\n- If you want to you can use use Pydiction in tandem with Vim 7's builtin omni-completion for Python (pythoncomplete.vim) as well as other forms of completion like SnipMate or Python-mode (see the Tips section). In fact, they can all make a great team.\r\n\r\n- Pydiction knows when you're completing an attribute vs a callable method. If it's a callable then it will automatically insert an opening parentheses.\r\n\r\n- The Tab key will work as normal for everything else. Pydiction will only try to use the Tab key to complete Python code if you're editing a Python file and you first type part of some Python module or keyword.\r\n\r\nTips\r\n====\r\n- If you want to have case-insensitive menu searches, :set ignorecase. Otherwise :set noic. Or add them to your vimrc.\r\n\r\n- SnipMate and Pydiction make a great team, but they both use the Tab key to complete. This is easy to fix, by adding the following to your .vimrc file:\r\n\r\n        \" Remap snipmate's trigger key from tab to <C-J>\r\n        imap <C-J> <Plug>snipMateNextOrTrigger\r\n        smap <C-J> <Plug>snipMateNextOrTrigger\r\n\r\n now `cl[Tab]` will use Pydiction to complete \"class\" and `cl<C-J>` will use the SnipMate snippet and you can still the tab key to iterate through the snippet placeholders.\r\n\r\n- Say you create a custom object, called `S` by doing something like:\r\n    \r\n         S = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n\r\n  You can complete dynamic object methods, such as `S.send()`, by using Vim 7's omni-completion ftplugin \"pythoncomplete.vim\" (requires Vim to be compiled with Python support) by doing:\r\n\r\n        S.s<Ctrl-x><Ctrl-o>\r\n\r\n You must import the module for this to work. (e.g. `import socket`). You may get unexpected results if you use rope.vim, python-mode.vim, autocomplpop.vim, supertab.vim or other completion or python plugins. Try disabling them individually to find out the culprit. I personally think that different types of completion need different commands, and have had a lot of bad luck trying to use SuperTab or similar plugins to try to force everything to use a Tab. If you don't like typing <C-X><C-O> you can remap them to something other than Tab, such as `<Leader>o`:\r\n\r\n        imap <Leader>o <C-X><C-O> \r\n\r\n If you use the `python-mode` plugin, I was able to get omnicomplete to work with it by deleting the line:\r\n\r\n        setlocal omnifunc=pymode#rope#completion \r\n        \r\n from python-mode/after/ftplugin/python.vim, but YMMV.\r\n\r\n- Similarly, you can use omni-completion for completing \"import module as\" syntax:\r\n\r\n        import itertools as itr\r\n        itr.<C-X><C-O>\r\n\r\n Or, if you really want it to work with Pydiction/Tab, then add your alias to complete-dict by copying an existing block like:\r\n\r\n        --- import itertools ---\r\n        itertools.chain(\r\n        itertools.ccombinations(\r\n        itertools.count(\r\n        ...\r\n\r\n and paste and edit that to replace itertools with itr:\r\n\r\n        --- import itertools as itr ---\r\n        itr.chain(\r\n        itr.ccombinations(\r\n        itr.count(\r\n        ...\r\n\r\n In fact, complete-dict contains some of this already for certain conventions, such as `Psycopg2` conventions of using `conn` and `cur` for connection and cursor objects, respectively. Near the top of the bundled complete-dict I've taken the liberty of adding:\r\n         \r\n        --- Psycopg2 / PEP 249 (Entered manually. Assumes conventional variable names: conn and cur) ---\r\n        conn.close(\r\n        conn.commit(\r\n        conn.rollback(\r\n        conn.cursor(\r\n        ...\r\n        cur.execute(\r\n        cur.executemany(\r\n        cur.fetchall(\r\n        ...\r\n\r\n- Because pydiction.py will complain if you try to add a module that already exists, this can make updating an existing module a little harder.\r\nThe workaround is to edit complete-dict and manually delete the related module sections. For example to update `__future__`, delete the sections `-- import __future__ ---` and `--- from __future__ import * ---`.\r\n\r\nPydiction v1.2.2 and greater adds special markers in each module section of complete-dict that tell you if a module is a \"root module\", meaning it's a top-level module or package that was specified as an argument to pydiction.py. This is helpful because pydiction.py will automatically dig into as many submodules as it can find, but it doesn't know about separate packages. For example `curses.textpad`, `curses.ascii`, `curses.panel` and `curses.wrapper` are not submodules of 'curses', so they have to be added separately, like:\r\n\r\n        $ ./pydiction curses curses.textpad curses.ascii curses.panel\r\n\r\nFortunately, you can `grep 'root module' complete-dict` to see a list of all the root modules:\r\n\r\n        $ grep 'root module' complete-dict | grep curses\r\n        --- import curses (py2.7.3/linux2/root module) ---\r\n        --- import curses.ascii (py2.7.3/linux2/root module) ---\r\n        --- import curses.textpad (py2.7.3/linux2/root module) ---\r\n        --- import curses.wrapper (py2.7.3/linux2/root module) ---\r\n\r\nAs you can see, pydiction.py also adds other information such as which version of Python and which operating system was used to add the module to the dictionary file. It will also put the version of the module if its `.__version__` attribute was set.\r\n\r\n- You can change the colors of the popup menu by editing your vim color scheme's source file and changing the values of `Pmenu` `PmenuSel` `PmenuSBar` and `PmenuThumb`. If you're using Vim in a terminal, change the values of ctermfg and ctermbg, otherwise change guifg and guibg. I use the molokai colorscheme and a terminal and use:\r\n\r\n        \" complete menu\r\n        hi Pmenu           ctermfg=green  ctermbg=black guifg=#66D9EF  guibg=#000000\r\n        hi PmenuSel        ctermfg=green  ctermbg=black                guibg=#808080\r\n        hi PmenuSbar                                                   guibg=#080808\r\n        hi PmenuThumb                                   guifg=#66D9EF\r\n\r\nFurther reading\r\n===============\r\n`:help ftplugin`\r\n`:help 'complete`\r\n`:help compl-dictionary`\r\n`:help popupmenu-completion`\r\n`:help popupmenu-keys`\r\n`:help iskeyword`\r\n\r\nhttp://docs.python.org/2/py-modindex.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}